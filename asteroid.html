<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroid Impact Simulator</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            background-color: #f0f0f0;
            overflow: hidden;
        }

        #legend-panel {
            width: 250px;
            padding: 20px;
            background-color: #e0e0e0;
            border-right: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        #legend-panel h2 {
            margin-top: 0;
            text-align: center;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
        }

        .slider-container label {
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .slider-container input[type="range"] {
            width: 100%;
        }

        .slider-container span {
            font-size: 0.8em;
            text-align: right;
            color: #555;
        }

        #map-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            overflow: hidden;
            position: relative;
        }

        #mapCanvas {
            border: 1px solid #000;
            background-color: transparent;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <div id="legend-panel">
        <h2>Impact Parameters</h2>
        
        <div class="slider-container">
            <label for="asteroidSize">Asteroid Diameter (km):</label>
            <input type="range" id="asteroidSize" min="1" max="50" value="10">
            <span id="asteroidSizeValue">10 km</span>
        </div>

        <div class="slider-container">
            <label for="asteroidVelocity">Asteroid Velocity (km/s):</label>
            <input type="range" id="asteroidVelocity" min="10" max="70" value="20" step="1">
            <span id="asteroidVelocityValue">20 km/s</span>
        </div>

        <div class="slider-container">
            <label for="debrisMultiplier">Debris Spread Factor:</label>
            <input type="range" id="debrisMultiplier" min="0.5" max="3" value="1.0" step="0.1">
            <span id="debrisMultiplierValue">1.0x</span>
        </div>

        <div class="slider-container">
            <label for="shockwaveMultiplier">Shockwave Intensity Factor:</label>
            <input type="range" id="shockwaveMultiplier" min="0.5" max="3" value="1" step="0.1">
            <span id="shockwaveMultiplierValue">1.0x</span>
        </div>
    </div>
    <div id="map-container">
        <canvas id="mapCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const mapContainer = document.getElementById('map-container');

        const asteroidSizeSlider = document.getElementById('asteroidSize');
        const asteroidVelocitySlider = document.getElementById('asteroidVelocity');
        const debrisMultiplierSlider = document.getElementById('debrisMultiplier');
        const shockwaveMultiplierSlider = document.getElementById('shockwaveMultiplier');

        const asteroidSizeValueDisplay = document.getElementById('asteroidSizeValue');
        const asteroidVelocityValueDisplay = document.getElementById('asteroidVelocityValue');
        const debrisMultiplierValueDisplay = document.getElementById('debrisMultiplierValue');
        const shockwaveMultiplierValueDisplay = document.getElementById('shockwaveMultiplierValue');

        let canvasWidth, canvasHeight;

        const backgroundImage = new Image();
        let imageLoaded = false;
        const imageUrl = 'north_america.jpg'; 

        let zoomLevel = 1.0;
        let viewOffsetX = 0; 
        let viewOffsetY = 0;

        const MIN_ZOOM = 0.1; 
        const MAX_ZOOM = 10.0;

        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let didPan = false;

        let simulationState = 'IDLE';
        const BASE_METEOR_ANIMATION_DURATION = 3000; 
        const MIN_ANIMATION_VELOCITY_REFERENCE = 10; 

        let meteor = {
            startX: 0, startY: 0, targetX: 0, targetY: 0,
            currentX: 0, currentY: 0, size: 5, progress: 0,
            animationDuration: BASE_METEOR_ANIMATION_DURATION * (MIN_ANIMATION_VELOCITY_REFERENCE / 20),
            startTime: 0
        };
        
        let impactData = {
            x: 0, y: 0,
            targetDirectRadius: 0, currentDirectRadius: 0,
            targetDebrisRadius: 0, currentDebrisRadius: 0,
            targetSeismicRadius: 0, currentSeismicRadius: 0,
            targetFalloutRadius: 0, currentFalloutRadius: 0,
            animationStartTime: 0, animationDuration: 2000,
            directSpeedFactor: 4.0, debrisSpeedFactor: 2.5,
            seismicSpeedFactor: 1.5, falloutSpeedFactor: 1.0 
        };

        const cities = [
            { name: "NYC", x: 870, y: 375 }, { name: "LA",  x: 510, y: 445 },
            { name: "CHI", x: 760, y: 365 }, { name: "HOU", x: 700, y: 480 },
            { name: "PHX", x: 560, y: 450 }, { name: "TOR", x: 825, y: 345 },
            { name: "MTL", x: 870, y: 330 }, { name: "MEX", x: 660, y: 585 },
            { name: "VAN", x: 490, y: 290 },  { name: "MIA", x: 825, y: 525 },
            { name: "DAL", x: 625, y: 385 }, { name: "SEA", x: 495, y: 310 },
            { name: "DEN", x: 750, y: 850 },  { name: "DC",  x: 845, y: 395 },
            { name: "SF",  x: 480, y: 405 },  { name: "ATL", x: 790, y: 445 },
            { name: "EDM", x: 565, y: 245 },  { name: "WPG", x: 690, y: 285 }
        ];

        backgroundImage.onload = () => {
            imageLoaded = true;
            console.log(`Image loaded: ${backgroundImage.naturalWidth}x${backgroundImage.naturalHeight}. Ensure this matches your file (expected 1200x729 for current city coords).`);
            setInitialView();
        };
        backgroundImage.onerror = () => {
            console.error("Failed to load background image from:", imageUrl);
            imageLoaded = false;
        };
        backgroundImage.src = imageUrl;

        function setInitialView() {
            if (!imageLoaded) return;
            
            const imgAspect = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
            const canvasAspect = canvas.width / canvas.height;

            if (imgAspect > canvasAspect) {
                zoomLevel = canvas.width / backgroundImage.naturalWidth;
            } else {
                zoomLevel = canvas.height / backgroundImage.naturalHeight;
            }
            zoomLevel *= 0.95; 
            zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel));

            viewOffsetX = (backgroundImage.naturalWidth / 2) - (canvas.width / 2 / zoomLevel);
            viewOffsetY = (backgroundImage.naturalHeight / 2) - (canvas.height / 2 / zoomLevel);
            
            constrainViewOffset();
        }

        function resizeCanvas() {
            canvasWidth = mapContainer.clientWidth;
            canvasHeight = mapContainer.clientHeight;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            if(imageLoaded) {
                setInitialView();
            }
        }

        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX / zoomLevel) + viewOffsetX,
                y: (screenY / zoomLevel) + viewOffsetY
            };
        }

        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX - viewOffsetX) * zoomLevel,
                y: (worldY - viewOffsetY) * zoomLevel
            };
        }
        
        function constrainViewOffset() {
            if (!imageLoaded) return;
            const maxOffsetX = backgroundImage.naturalWidth - (canvas.width / zoomLevel) * 0.1; 
            const maxOffsetY = backgroundImage.naturalHeight - (canvas.height / zoomLevel) * 0.1;
            const minOffsetX = -(canvas.width / zoomLevel) * 0.9; 
            const minOffsetY = -(canvas.height / zoomLevel) * 0.9;

            viewOffsetX = Math.max(minOffsetX, Math.min(maxOffsetX, viewOffsetX));
            viewOffsetY = Math.max(minOffsetY, Math.min(maxOffsetY, viewOffsetY));
        }

        function drawBackgroundImage() {
            if (!imageLoaded) {
                ctx.fillStyle = '#555';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = "16px Arial";
                ctx.fillText("Background image ('north_america.jpg') loading or failed.", canvas.width/2, canvas.height/2);
                ctx.fillText("Make sure it's in the same folder as the HTML file.", canvas.width/2, canvas.height/2 + 20);
                return;
            }
            ctx.drawImage(
                backgroundImage,
                viewOffsetX, viewOffsetY,
                canvas.width / zoomLevel, canvas.height / zoomLevel,
                0, 0,
                canvas.width, canvas.height
            );
        }
        
        function drawCityLabels() {
            if (!imageLoaded) return;
            
            const baseFontSize = 8;
            const baseDotRadius = 1.5;
            const currentFontSize = Math.max(5, baseFontSize * zoomLevel);
            const dotRadius = Math.max(1, baseDotRadius * zoomLevel);

            ctx.font = `${currentFontSize}px Arial`;
            ctx.textAlign = 'left';
            
            cities.forEach(city => {
                const screenPos = worldToScreen(city.x, city.y);
                
                if (screenPos.x < -30 || screenPos.x > canvas.width + 30 || 
                    screenPos.y < -30 || screenPos.y > canvas.height + 30) {
                    return;
                }

                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = Math.max(0.5, 1 / zoomLevel);
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, dotRadius, 0, Math.PI * 2);
                ctx.fill();
                if (zoomLevel > 0.2) ctx.stroke();

                if (zoomLevel > 0.25) { 
                    const textX = screenPos.x + (dotRadius * 1.5);
                    const textY = screenPos.y + (dotRadius * 0.5);
                    
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = Math.max(0.25, 0.75 / zoomLevel); 
                    ctx.strokeText(city.name, textX, textY);
                    
                    ctx.fillStyle = 'white';
                    ctx.fillText(city.name, textX, textY);
                }
            });
        }

        function drawMeteor() {
            if (simulationState !== 'ANIMATING_METEOR') return;

            const elapsed = Date.now() - meteor.startTime;
            meteor.progress = Math.min(1, elapsed / meteor.animationDuration);
            const targetScreenPos = worldToScreen(meteor.targetX, meteor.targetY);
            
            meteor.currentX = meteor.startX + (targetScreenPos.x - meteor.startX) * meteor.progress;
            meteor.currentY = meteor.startY + (targetScreenPos.y - meteor.startY) * meteor.progress;

            const meteorScreenSize = meteor.size * zoomLevel;

            ctx.beginPath();
            ctx.arc(meteor.currentX, meteor.currentY, Math.max(1, meteorScreenSize), 0, Math.PI * 2);
            ctx.fillStyle = 'orangered';
            ctx.fill();
            
            if (meteor.progress > 0.05 && meteorScreenSize > 0.5) {
                const tailLength = meteorScreenSize * 3;
                const dx = targetScreenPos.x - meteor.startX;
                const dy = targetScreenPos.y - meteor.startY;
                 if (dx !== 0 || dy !== 0) {
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const tailX = meteor.currentX - (dx/dist) * tailLength;
                    const tailY = meteor.currentY - (dy/dist) * tailLength;
                    
                    ctx.beginPath();
                    ctx.moveTo(tailX, tailY);
                    ctx.lineTo(meteor.currentX, meteor.currentY);
                    ctx.strokeStyle = 'rgba(255, 165, 0, 0.5)';
                    ctx.lineWidth = Math.max(0.5, meteorScreenSize * 0.8);
                    ctx.stroke();
                }
            }

            if (meteor.progress >= 1) {
                simulationState = 'ANIMATING_IMPACT_EXPANSION';
                calculateImpactEffectSizes(); // This uses current slider values
                impactData.animationStartTime = Date.now();
                if (impactData.targetFalloutRadius > 0) {
                    impactData.animationDuration = Math.max(1500, Math.min(5000, impactData.targetFalloutRadius * 0.1 * zoomLevel));
                } else {
                    impactData.animationDuration = 2000;
                }
            }
        }
        
        function calculateImpactEffectSizes() {
            if (!imageLoaded) return;
            const baseSizeParam = parseFloat(asteroidSizeSlider.value);
            const currentVelocity = parseFloat(asteroidVelocitySlider.value);
            const debrisMult = parseFloat(debrisMultiplierSlider.value);
            const shockwaveMult = parseFloat(shockwaveMultiplierSlider.value);

            const referenceVelocity = 20.0; 
            const safeCurrentVelocity = Math.max(0.1, currentVelocity); 
            const velocityEnergyFactor = Math.sqrt(safeCurrentVelocity / referenceVelocity);

            const estMapWidthKm = 6000;
            const worldPixelsPerKm = backgroundImage.naturalWidth / estMapWidthKm; 

            const visualMultiplier = 30; 

            impactData.targetDirectRadius = baseSizeParam * 0.25 * worldPixelsPerKm * visualMultiplier * velocityEnergyFactor;
            impactData.targetDebrisRadius = baseSizeParam * 0.8 * debrisMult * worldPixelsPerKm * visualMultiplier * velocityEnergyFactor;
            impactData.targetSeismicRadius = baseSizeParam * 1.5 * shockwaveMult * worldPixelsPerKm * visualMultiplier * velocityEnergyFactor;
            impactData.targetFalloutRadius = baseSizeParam * 2.5 * debrisMult * worldPixelsPerKm * visualMultiplier * velocityEnergyFactor;

            // These are reset here to prepare for the NEW impact animation
            impactData.currentDirectRadius = 0;
            impactData.currentDebrisRadius = 0;
            impactData.currentSeismicRadius = 0;
            impactData.currentFalloutRadius = 0;
        }

        function drawImpactEffects() {
            // Only draw if an impact is active and its effects should be shown
            if (simulationState !== 'ANIMATING_IMPACT_EXPANSION' || !impactData.x) return;

            const elapsed = Date.now() - impactData.animationStartTime;

            function getAnimatedRadius(targetRadius, speedFactor) {
                const effectiveDuration = impactData.animationDuration / speedFactor;
                const progress = Math.min(1, elapsed / effectiveDuration);
                return targetRadius * progress;
            }

            impactData.currentFalloutRadius = getAnimatedRadius(impactData.targetFalloutRadius, impactData.falloutSpeedFactor);
            impactData.currentSeismicRadius = getAnimatedRadius(impactData.targetSeismicRadius, impactData.seismicSpeedFactor);
            impactData.currentDebrisRadius = getAnimatedRadius(impactData.targetDebrisRadius, impactData.debrisSpeedFactor);
            impactData.currentDirectRadius = getAnimatedRadius(impactData.targetDirectRadius, impactData.directSpeedFactor);
            
            const screenPos = worldToScreen(impactData.x, impactData.y);

            ctx.globalAlpha = 0.6;

            const drawRing = (worldRadius, color) => {
                if (worldRadius <=0) return;
                const screenRadius = worldRadius * zoomLevel;
                if (screenRadius < 0.5) return;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            };

            drawRing(impactData.currentFalloutRadius, 'rgba(100, 100, 100, 0.7)');
            drawRing(impactData.currentSeismicRadius, 'rgba(255, 140, 0, 0.8)');
            drawRing(impactData.currentDebrisRadius, 'rgba(139, 69, 19, 0.9)');
            drawRing(impactData.currentDirectRadius, 'rgba(255, 69, 0, 1.0)');
            
            ctx.globalAlpha = 1.0;
        }

        let animationFrameId = null;
        function draw() {
            animationFrameId = requestAnimationFrame(draw);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackgroundImage();
            drawCityLabels();

            if (simulationState === 'ANIMATING_METEOR') {
                drawMeteor();
            } else if (simulationState === 'ANIMATING_IMPACT_EXPANSION') {
                drawImpactEffects();
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            isPanning = true; 
            didPan = false; 
            panStartX = e.clientX;
            panStartY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isPanning) return;

            const dxScreen = e.clientX - panStartX;
            const dyScreen = e.clientY - panStartY;

            if (!didPan && (Math.abs(dxScreen) > 3 || Math.abs(dyScreen) > 3)) {
                didPan = true;
            }
            
            if (didPan) {
              viewOffsetX -= dxScreen / zoomLevel;
              viewOffsetY -= dyScreen / zoomLevel;
              panStartX = e.clientX; 
              panStartY = e.clientY;
              constrainViewOffset();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button !== 0) return;
            if (isPanning && !didPan) {
                handleCanvasClick(e);
            }
            isPanning = false;
            didPan = false;
        });

        canvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                didPan = false;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top; 

            const worldMouseBeforeZoom = screenToWorld(mouseX, mouseY);
            const zoomFactor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
            const newZoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel * zoomFactor));
            
            if (newZoomLevel !== zoomLevel) {
                zoomLevel = newZoomLevel;
                viewOffsetX = worldMouseBeforeZoom.x - (mouseX / zoomLevel);
                viewOffsetY = worldMouseBeforeZoom.y - (mouseY / zoomLevel);
                constrainViewOffset();
            }
        });

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const clickX_screen = event.clientX - rect.left;
            const clickY_screen = event.clientY - rect.top;

            const worldClick = screenToWorld(clickX_screen, clickY_screen);
            const currentVelocity = parseFloat(asteroidVelocitySlider.value);
            const safeCurrentVelocity = Math.max(0.1, currentVelocity);

            simulationState = 'ANIMATING_METEOR';
            meteor.targetX = worldClick.x;
            meteor.targetY = worldClick.y;
            
            meteor.startX = Math.random() * canvas.width;
            meteor.startY = -30; 
            
            meteor.currentX = meteor.startX;
            meteor.currentY = meteor.startY;
            meteor.progress = 0;
            meteor.startTime = Date.now();
            meteor.animationDuration = BASE_METEOR_ANIMATION_DURATION * (MIN_ANIMATION_VELOCITY_REFERENCE / safeCurrentVelocity);
            meteor.animationDuration = Math.max(500, meteor.animationDuration); 

            meteor.size = Math.max(1, parseFloat(asteroidSizeSlider.value) / 4 + 1);
            
            impactData.x = worldClick.x;
            impactData.y = worldClick.y;
            // Target radii will be calculated by calculateImpactEffectSizes when meteor hits
            // Current radii are reset here because they might have old values if a previous reset happened.
            impactData.currentDirectRadius = 0;
            impactData.currentDebrisRadius = 0;
            impactData.currentSeismicRadius = 0;
            impactData.currentFalloutRadius = 0;
        }

        function resetImpactVisuals() {
            simulationState = 'IDLE';
            impactData.x = 0; 
            impactData.y = 0;
            impactData.currentDirectRadius = 0;
            impactData.currentDebrisRadius = 0;
            impactData.currentSeismicRadius = 0;
            impactData.currentFalloutRadius = 0;
        }

        function updateOnSliderChange() {
            // If an impact's effects are currently visible (or animating), reset them.
            if (simulationState === 'ANIMATING_IMPACT_EXPANSION') {
                resetImpactVisuals();
            }
            // Always update the potential meteor size for the *next* impact
            meteor.size = Math.max(1, parseFloat(asteroidSizeSlider.value) / 4 + 1);
        }


        asteroidSizeSlider.addEventListener('input', (e) => {
            asteroidSizeValueDisplay.textContent = `${e.target.value} km`;
            updateOnSliderChange();
        });
        asteroidVelocitySlider.addEventListener('input', (e) => {
            asteroidVelocityValueDisplay.textContent = `${e.target.value} km/s`;
            updateOnSliderChange();
        });
        debrisMultiplierSlider.addEventListener('input', (e) => {
            debrisMultiplierValueDisplay.textContent = `${e.target.value}x`;
            updateOnSliderChange();
        });
        shockwaveMultiplierSlider.addEventListener('input', (e) => {
            shockwaveMultiplierValueDisplay.textContent = `${e.target.value}x`;
            updateOnSliderChange();
        });

        window.addEventListener('resize', resizeCanvas);
        
        resizeCanvas(); 
        if (!animationFrameId) {
            draw();
        }
    </script>
</body>
</html>