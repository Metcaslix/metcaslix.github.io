<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: black; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        canvas { display: block; cursor: crosshair; }
        .controls { position: absolute; top: 10px; left: 10px; background-color: rgba(50, 50, 50, 0.8); padding: 10px; border-radius: 5px; z-index: 10; }
        .controls label { margin-right: 10px; }
        .controls input[type="radio"], .controls input[type="checkbox"] { margin-right: 5px; }
        .controls button { margin-top: 5px; margin-right: 5px;}
        .info { position: absolute; bottom: 10px; left: 10px; font-size: 0.8em; color: #aaa; background-color: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px;}

        .side-menu-toggle { position: absolute; top: 10px; right: 10px; padding: 8px 12px; background-color: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; z-index: 20; }
        .side-menu { position: absolute; top: 50px; right: -320px; width: 300px; height: calc(100vh - 70px); background-color: rgba(40, 40, 40, 0.95); border-left: 1px solid #555; border-bottom-left-radius: 5px; padding: 10px; transition: right 0.3s ease-in-out; overflow-y: auto; z-index: 19; }
        .side-menu.open { right: 0; }
        .side-menu fieldset { border: 1px solid #666; border-radius: 4px; margin-bottom: 15px; padding: 0; }
        .side-menu legend { color: #ddd; font-weight: bold; padding: 5px 10px; cursor: pointer; display: block; background-color: rgba(80,80,80,0.3); border-bottom: 1px solid #666; margin-bottom: 0; }
        .side-menu legend::before { content: '\25B8'; margin-right: 5px; display: inline-block; transition: transform 0.2s ease-in-out; }
        .side-menu legend.expanded::before { transform: rotate(90deg); }
        .side-menu .fieldset-content { padding: 10px; }
        .side-menu .fieldset-content.hidden { display: none; }
        .side-menu label { display: block; margin-bottom: 3px; font-size: 0.9em; color: #ccc; }
        .side-menu .param-group { margin-bottom: 12px; }
        .side-menu input[type="number"] { width: 70px; padding: 4px; margin-right: 10px; background-color: #222; border: 1px solid #555; color: white; border-radius: 3px; box-sizing: border-box; vertical-align: middle;}
        .side-menu input[type="range"] { width: calc(100% - 95px); vertical-align: middle; cursor: pointer;}
        .side-menu button { background-color: #555; border: 1px solid #777; color: white; padding: 5px 10px; border-radius:3px; cursor:pointer; margin-top: 10px; }
        .side-menu button:hover { background-color: #666; }
    </style>
</head>
<body>
    <div class="controls">
        <label>Spawn Mass:</label>
        <input type="radio" name="mass" value="1" id="mass1"> <label for="mass1">1</label>
        <input type="radio" name="mass" value="100" id="mass100" checked> <label for="mass100">100</label>
        <input type="radio" name="mass" value="1000" id="mass1000"> <label for="mass1000">1k</label>
        <input type="radio" name="mass" value="10000" id="mass10k"> <label for="mass10k">10k</label>
        <input type="radio" name="mass" value="100000" id="mass100k"> <label for="mass100k">100k</label>
        <br>
        <input type="checkbox" id="toggleTracks"> <label for="toggleTracks">Show Tracks</label>
        <button id="pauseResume">Pause</button>
        <button id="clearAll">Clear All & Reset View</button>
        <button id="generateDisk">Generate Proto-Disk</button>
    </div>

    <button class="side-menu-toggle" id="toggleSideMenu">Params &raquo;</button>
    <div class="side-menu" id="sideMenu">
        <fieldset id="protoDiskParamsFieldset">
            <legend id="protoDiskParamsLegend">Proto-Disk Parameters</legend>
            <div class="fieldset-content" id="protoDiskParamsContent">
                <div class="param-group">
                    <label for="pdNumObjectsNum">Number of Objects:</label>
                    <input type="number" id="pdNumObjectsNum" min="10" max="1000" step="10">
                    <input type="range" id="pdNumObjectsRange" min="10" max="1000" step="10">
                </div>
                <div class="param-group">
                    <label for="pdCentralMassNum">Central Mass:</label>
                    <input type="number" id="pdCentralMassNum" min="0" max="100000" step="100">
                    <input type="range" id="pdCentralMassRange" min="0" max="100000" step="1000">
                </div>
                <div class="param-group">
                    <label for="pdMinRadiusNum">Min Disk Radius:</label>
                    <input type="number" id="pdMinRadiusNum" min="1" max="500" step="1">
                    <input type="range" id="pdMinRadiusRange" min="1" max="500" step="5">
                </div>
                <div class="param-group">
                    <label for="pdMaxRadiusNum">Max Disk Radius:</label>
                    <input type="number" id="pdMaxRadiusNum" min="10" max="1000" step="10">
                    <input type="range" id="pdMaxRadiusRange" min="10" max="1000" step="10">
                </div>
                <div class="param-group">
                    <label for="pdMinParticleMassNum">Min Particle Mass:</label>
                    <input type="number" id="pdMinParticleMassNum" min="0.1" max="100" step="0.1">
                    <input type="range" id="pdMinParticleMassRange" min="0.1" max="100" step="0.1">
                </div>
                <div class="param-group">
                    <label for="pdMaxParticleMassNum">Max Particle Mass:</label>
                    <input type="number" id="pdMaxParticleMassNum" min="0.1" max="100" step="0.1">
                    <input type="range" id="pdMaxParticleMassRange" min="0.1" max="100" step="0.1">
                </div>
                <div class="param-group">
                    <label for="pdRotationSpeedMultNum">Rotation Speed Multiplier:</label>
                    <input type="number" id="pdRotationSpeedMultNum" min="0.1" max="2.0" step="0.01">
                    <input type="range" id="pdRotationSpeedMultRange" min="0.1" max="2.0" step="0.01">
                </div>
                <div class="param-group">
                    <label for="pdVelocityRandomnessNum">Velocity Randomness Factor:</label>
                    <input type="number" id="pdVelocityRandomnessNum" min="0" max="1.0" step="0.01">
                    <input type="range" id="pdVelocityRandomnessRange" min="0" max="1.0" step="0.01">
                </div>
                <button id="resetProtoDiskParams">Reset Proto-Disk Defaults</button>
            </div>
        </fieldset>
    </div>

    <canvas id="gravityCanvas"></canvas>
    <div class="info">
        by metcas v1.2-202505302030<br>
        Left-click & drag to spawn. Alt + Left-click on object to stop it. <br>
        Right-click while dragging to cancel. Middle-click+drag to Pan. Wheel to Zoom. <br>
        Ctrl + Right-click on object to delete. Spacebar to Pause/Resume.
    </div>

    <script>
        const canvas = document.getElementById('gravityCanvas'); const ctx = canvas.getContext('2d');
        let bodies = []; let persistentTracks = []; let G = 0.5; const DT = 0.016; const VELOCITY_SCALE = 0.05; const POWER_DISPLAY_SCALE_FACTOR = 100; const PERSISTENT_TRACK_COLOR = 'hsl(0, 90%, 60%)'; const TRACK_ALPHA = 0.7; const DEFAULT_BODY_COLOR = 'hsl(270, 70%, 70%)';
        const PREDICTION_STEPS = 1600; const PREDICTION_DT = DT; const PREDICTION_LINE_BASE_COLOR = { r: 0, g: 150, b: 255 }; const PREDICTION_MAX_ALPHA = 0.5; const PRECESSION_K_FACTOR = 50;
        let showTracks = false; let currentSpawnMass = 100; let isPaused = false;
        const view = { scale: 1.0, offsetX: 0, offsetY: 0, minZoom: 0.05, maxZoom: 20 };
        let isDraggingSpawn = false, dragStartWorldX, dragStartWorldY, currentMouseScreenX, currentMouseScreenY;
        let isPanning = false, panLastScreenX, panLastScreenY;
        const colorStops = []; const _colorStopsData = [ { mass: 1, hslStr: 'hsl(0, 100%, 50%)' },{ mass: 100, hslStr: 'hsl(30, 100%, 50%)' },{ mass: 1000, hslStr: 'hsl(60, 100%, 50%)' },{ mass: 10000, hslStr: 'hsl(195, 100%, 70%)' },{ mass: 100000, hslStr: 'hsl(0, 0%, 100%)' }]; _colorStopsData.forEach(s => { const p = parseHslString(s.hslStr); if(p) {s.h=p.h; s.s=p.s; s.l=p.l; const rgb = hslToRgb(p.h,p.s,p.l); if(!isNaN(rgb.r)){s.r=rgb.r;s.g=rgb.g;s.b=rgb.b;} else {s.r=128;s.g=128;s.b=128;}} else {s.r=128;s.g=128;s.b=128;} }); colorStops.splice(0, colorStops.length, ..._colorStopsData);
        function parseHslString(hslStr){const m=hslStr.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/); return m?{h:parseInt(m[1]),s:parseInt(m[2])/100,l:parseInt(m[3])/100}:null;}
        function formatHslString(h,s,l){return isNaN(h)||isNaN(s)||isNaN(l)?DEFAULT_BODY_COLOR:`hsl(${Math.round(h)}, ${Math.round(s*100)}%, ${Math.round(l*100)}%)`;}
        function hslToRgb(h,s,l){let r,g,b;if(s===0){r=g=b=l;}else{const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;const H=h/360;const t=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};r=t(p,q,H+1/3);g=t(p,q,H);b=t(p,q,H-1/3);}return{r:Math.round(r*255),g:Math.round(g*255),b:Math.round(b*255)};}
        function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;const M=Math.max(r,g,b),m=Math.min(r,g,b);let h,s,l=(M+m)/2;if(M===m){h=0;s=0;}else{const d=M-m;s=l>0.5?d/(2-M-m):d/(M+m);switch(M){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;}h/=6;}if(isNaN(h))h=0;if(isNaN(s))s=0;return{h:h*360,s:s,l:l};}
        function getColorForMass(m){try{if(isNaN(m)||!isFinite(m))return DEFAULT_BODY_COLOR;if(m<=colorStops[0].mass)return colorStops[0].hslStr;for(let i=0;i<colorStops.length-1;i++){const ls=colorStops[i],us=colorStops[i+1];if(m<=us.mass){if(isNaN(ls.r)||isNaN(us.r))return DEFAULT_BODY_COLOR;const rg=us.mass-ls.mass;if(rg===0)return us.hslStr;const t=(m-ls.mass)/rg;const r=Math.round(ls.r*(1-t)+us.r*t),g=Math.round(ls.g*(1-t)+us.g*t),b=Math.round(ls.b*(1-t)+us.b*t);const hsl=rgbToHsl(r,g,b);return formatHslString(hsl.h,hsl.s,hsl.l);}}return colorStops[colorStops.length-1].hslStr;}catch(e){return DEFAULT_BODY_COLOR;}}
        function getHslaColor(hsl,a){if(typeof hsl!=='string'||!hsl.startsWith('hsl('))hsl=DEFAULT_BODY_COLOR;return hsl.replace('hsl(','hsla(').replace(')',`, ${a})`);}

        const defaultProtoDiskParams = { numObjects: 200, centralMass: 5000, minRadius: 50, maxRadius: 300, minParticleMass: 0.5, maxParticleMass: 5, rotationSpeedMult: 0.8, velocityRandomness: 0.15 };
        let currentProtoDiskParams = { ...defaultProtoDiskParams };
        const sideMenu = document.getElementById('sideMenu');
        const toggleSideMenuButton = document.getElementById('toggleSideMenu');
        toggleSideMenuButton.addEventListener('click', () => { sideMenu.classList.toggle('open'); toggleSideMenuButton.textContent = sideMenu.classList.contains('open') ? 'Params \u00AB' : 'Params \u00BB'; });
        const pdInputs = { numObjects: { num: document.getElementById('pdNumObjectsNum'), range: document.getElementById('pdNumObjectsRange') }, centralMass: { num: document.getElementById('pdCentralMassNum'), range: document.getElementById('pdCentralMassRange') }, minRadius: { num: document.getElementById('pdMinRadiusNum'), range: document.getElementById('pdMinRadiusRange') }, maxRadius: { num: document.getElementById('pdMaxRadiusNum'), range: document.getElementById('pdMaxRadiusRange') }, minParticleMass: { num: document.getElementById('pdMinParticleMassNum'), range: document.getElementById('pdMinParticleMassRange') }, maxParticleMass: { num: document.getElementById('pdMaxParticleMassNum'),  range: document.getElementById('pdMaxParticleMassRange') }, rotationSpeedMult: { num: document.getElementById('pdRotationSpeedMultNum'), range: document.getElementById('pdRotationSpeedMultRange') }, velocityRandomness: { num: document.getElementById('pdVelocityRandomnessNum'),range: document.getElementById('pdVelocityRandomnessRange') } };
        function populateProtoDiskInputs() { for (const key in currentProtoDiskParams) { if (pdInputs[key]) { pdInputs[key].num.value = currentProtoDiskParams[key]; pdInputs[key].range.value = currentProtoDiskParams[key]; } } }
        function setupProtoDiskParamListeners() { for (const key in pdInputs) { if (pdInputs[key]) { pdInputs[key].num.addEventListener('input', (e) => { const value = parseFloat(e.target.value); currentProtoDiskParams[key] = isNaN(value) ? defaultProtoDiskParams[key] : value; pdInputs[key].range.value = currentProtoDiskParams[key]; }); pdInputs[key].range.addEventListener('input', (e) => { const value = parseFloat(e.target.value); currentProtoDiskParams[key] = value; pdInputs[key].num.value = value; }); } } document.getElementById('resetProtoDiskParams').addEventListener('click', () => { currentProtoDiskParams = { ...defaultProtoDiskParams }; populateProtoDiskInputs(); }); }
        function makeFieldsetCollapsible(legendId, contentId, startExpanded = true) { const legend = document.getElementById(legendId); const content = document.getElementById(contentId); if (!legend || !content) { console.error("Collapsible fieldset elements not found:", legendId, contentId); return; } if (startExpanded) { legend.classList.add('expanded'); } else { content.classList.add('hidden'); } legend.addEventListener('click', () => { content.classList.toggle('hidden'); legend.classList.toggle('expanded'); }); }
        
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight;} window.addEventListener('resize', resizeCanvas); resizeCanvas(); function screenToWorld(screenX, screenY) { const worldX = (screenX - canvas.width / 2) / view.scale + view.offsetX; const worldY = (screenY - canvas.height / 2) / view.scale + view.offsetY; return { x: worldX, y: worldY }; }
        document.querySelectorAll('input[name="mass"]').forEach(radio => { radio.addEventListener('change', (event) => { currentSpawnMass = parseFloat(event.target.value); }); }); currentSpawnMass = parseFloat(document.querySelector('input[name="mass"]:checked').value);
        const toggleTracksCheckbox = document.getElementById('toggleTracks'); toggleTracksCheckbox.addEventListener('change', (event) => { showTracks = event.target.checked; if (!showTracks) { bodies.forEach(body => body.history = []); persistentTracks = []; }});
        const pauseResumeButton = document.getElementById('pauseResume'); document.getElementById('clearAll').addEventListener('click', () => { bodies = []; persistentTracks = []; view.scale = 1.0; view.offsetX = 0; view.offsetY = 0; if(isPaused){ isPaused=false; pauseResumeButton.textContent="Pause"; } });
        pauseResumeButton.addEventListener('click', togglePause); window.addEventListener('keydown', (event) => { const activeElement = document.activeElement; const inputs = ['input', 'textarea', 'select', 'button']; if (activeElement && inputs.includes(activeElement.tagName.toLowerCase())) { if (activeElement.type !== 'radio' && activeElement.type !== 'checkbox') { return; } } if (event.code === 'Space') { event.preventDefault(); togglePause(); } });
        function togglePause() { isPaused = !isPaused; pauseResumeButton.textContent = isPaused ? "Resume" : "Pause"; }
        class CelestialBody { constructor(x,y,vx,vy,mass){this.x=x;this.y=y;this.vx=vx;this.vy=vy;if(isNaN(mass)||mass<=0)this.mass=1;else this.mass=mass;this.radius=Math.max(1,Math.pow(this.mass,1/3)*0.15+0.5);this.color=getColorForMass(this.mass);this.history=[];this.ax=0;this.ay=0;}applyForce(fx,fy){if(isNaN(fx)||isNaN(fy))return;if(this.mass===0)return;this.ax+=fx/this.mass;this.ay+=fy/this.mass;}update(dt){if(isNaN(this.ax)||isNaN(this.ay)){this.ax=0;this.ay=0;}this.vx+=this.ax*dt;this.vy+=this.ay*dt;if(isNaN(this.vx)||isNaN(this.vy)){this.vx=0;this.vy=0;}this.x+=this.vx*dt;this.y+=this.vy*dt;if(isNaN(this.x)||isNaN(this.y)){bodies=bodies.filter(b=>b!==this);return;}this.ax=0;this.ay=0;if(showTracks)this.history.push({x:this.x,y:this.y});}draw(ctx){if(showTracks&&this.history.length>1){ctx.beginPath();let firstValid=true; for(let i=0;i<this.history.length;i++){if(isNaN(this.history[i].x)||isNaN(this.history[i].y))continue; if(firstValid){ctx.moveTo(this.history[i].x,this.history[i].y);firstValid=false;}else{ctx.lineTo(this.history[i].x,this.history[i].y);}} if(!firstValid) {ctx.strokeStyle=getHslaColor(this.color,TRACK_ALPHA);ctx.lineWidth=1.5/view.scale;ctx.stroke();}}ctx.beginPath();if(isNaN(this.x)||isNaN(this.y)||isNaN(this.radius)||this.radius<=0)return;ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.fillStyle=this.color;ctx.fill();}}
        canvas.addEventListener('mousedown', (event) => { const worldMouse = screenToWorld(event.clientX, event.clientY); if (event.altKey && event.button === 0) { event.preventDefault(); for (let i = 0; i < bodies.length; i++) { const body = bodies[i]; if (isNaN(body.x) || isNaN(body.y) || isNaN(body.radius) || body.radius <= 0) continue; const distSq = (body.x - worldMouse.x)**2 + (body.y - worldMouse.y)**2; if (distSq < body.radius**2) { body.vx = 0; body.vy = 0; break; } } isDraggingSpawn = false;  } else if (event.button === 0 && !isDraggingSpawn && !isPanning && !event.altKey) { isDraggingSpawn = true; dragStartWorldX = worldMouse.x; dragStartWorldY = worldMouse.y; currentMouseScreenX = event.clientX; currentMouseScreenY = event.clientY; } else if (event.button === 1) { isPanning = true; panLastScreenX = event.clientX; panLastScreenY = event.clientY; canvas.style.cursor = 'grabbing'; event.preventDefault(); }});
        window.addEventListener('mousemove', (event) => { if (isDraggingSpawn) { currentMouseScreenX = event.clientX; currentMouseScreenY = event.clientY; } else if (isPanning) { const dxScreen = event.clientX - panLastScreenX; const dyScreen = event.clientY - panLastScreenY; view.offsetX -= dxScreen / view.scale; view.offsetY -= dyScreen / view.scale; panLastScreenX = event.clientX; panLastScreenY = event.clientY; }});
        window.addEventListener('mouseup', (event) => { if (event.button === 0 && isDraggingSpawn) { const endMouseWorld = screenToWorld(currentMouseScreenX, currentMouseScreenY); const dxWorld = endMouseWorld.x - dragStartWorldX; const dyWorld = endMouseWorld.y - dragStartWorldY; const initialVx = dxWorld * VELOCITY_SCALE; const initialVy = dyWorld * VELOCITY_SCALE; bodies.push(new CelestialBody(dragStartWorldX, dragStartWorldY, initialVx, initialVy, currentSpawnMass)); isDraggingSpawn = false; } else if (event.button === 1 && isPanning) { isPanning = false; canvas.style.cursor = 'crosshair'; }});
        canvas.addEventListener('wheel', (event) => { event.preventDefault(); const scrollDelta = Math.sign(event.deltaY); const zoomFactor = 0.1; const mouseBeforeZoomWorld = screenToWorld(event.clientX, event.clientY); let newScale = view.scale * (1 - scrollDelta * zoomFactor); newScale = Math.max(view.minZoom, Math.min(view.maxZoom, newScale)); view.scale = newScale; view.offsetX = mouseBeforeZoomWorld.x - (event.clientX - canvas.width / 2) / view.scale; view.offsetY = mouseBeforeZoomWorld.y - (event.clientY - canvas.height / 2) / view.scale;});
        canvas.addEventListener('contextmenu', (event) => { event.preventDefault(); if (event.ctrlKey) { const mouseWorld = screenToWorld(event.clientX, event.clientY); for (let i = bodies.length - 1; i >= 0; i--) { const body = bodies[i]; if (isNaN(body.x) || isNaN(body.y) || isNaN(body.radius)) continue; const distSq = (body.x - mouseWorld.x)**2 + (body.y - worldMouse.y)**2; if (distSq < body.radius**2) { if (showTracks && body.history.length > 1) { persistentTracks.push({ history: [...body.history], color: PERSISTENT_TRACK_COLOR }); } bodies.splice(i, 1); break;}}} else if (isDraggingSpawn) { isDraggingSpawn = false; }});
        document.getElementById('generateDisk').addEventListener('click', generateProtoDisk);
        function generateProtoDisk() { const diskCenterX = view.offsetX; const diskCenterY = view.offsetY; const numObjects = currentProtoDiskParams.numObjects; const centralMassValue = currentProtoDiskParams.centralMass; const minDiskRadius = currentProtoDiskParams.minRadius; const maxDiskRadius = currentProtoDiskParams.maxRadius; const minParticleMass = currentProtoDiskParams.minParticleMass; const maxParticleMass = currentProtoDiskParams.maxParticleMass; const diskRotationSpeedMultiplier = currentProtoDiskParams.rotationSpeedMult; const velocityRandomnessFactor = currentProtoDiskParams.velocityRandomness; if (centralMassValue > 0) { bodies.push(new CelestialBody(diskCenterX, diskCenterY, 0, 0, centralMassValue)); } for (let i = 0; i < numObjects; i++) { const angle = Math.random() * 2 * Math.PI; const radiusFactor = Math.sqrt(Math.random()); const r = minDiskRadius + radiusFactor * (maxDiskRadius - minDiskRadius); const particleMass = minParticleMass + Math.random() * (maxParticleMass - minParticleMass); const posX = diskCenterX + r * Math.cos(angle); const posY = diskCenterY + r * Math.sin(angle); let speed = 0; if (r > 0.01 && centralMassValue > 0) { speed = Math.sqrt(G * centralMassValue / r); } else if (r > 0.01) { speed = Math.sqrt(G * (maxParticleMass * numObjects * 0.1) / r) * 0.5; } speed *= diskRotationSpeedMultiplier; let vx_tangential = -speed * Math.sin(angle); let vy_tangential =  speed * Math.cos(angle); const scatterMagnitude = velocityRandomnessFactor * speed; const vx_scatter = (Math.random() - 0.5) * 2 * scatterMagnitude; const vy_scatter = (Math.random() - 0.5) * 2 * scatterMagnitude; const final_vx = vx_tangential + vx_scatter; const final_vy = vy_tangential + vy_scatter; bodies.push(new CelestialBody(posX, posY, final_vx, final_vy, particleMass)); } console.log(`Generated disk with ${numObjects} particles and a central mass of ${centralMassValue}.`); }
        function updatePhysics(dt) { for (let i = 0; i < bodies.length; i++) { for (let j = i + 1; j < bodies.length; j++) { const body1 = bodies[i]; const body2 = bodies[j]; if (!body1 || !body2 || isNaN(body1.mass) || isNaN(body2.mass) || isNaN(body1.x) || isNaN(body2.x)) { continue; } const dx = body2.x - body1.x; const dy = body2.y - body1.y; let distSq = dx * dx + dy * dy; if (isNaN(distSq) || distSq <= 0) { continue; } const dist = Math.sqrt(distSq); if (dist < body1.radius + body2.radius) { const totalMass = body1.mass + body2.mass; if (isNaN(totalMass) || totalMass <=0) { continue; } const newVx = (body1.mass * body1.vx + body2.mass * body2.vx) / totalMass; const newVy = (body1.mass * body1.vy + body2.mass * body2.vy) / totalMass; let absorber, absorbed; if (body1.mass >= body2.mass) { absorber = body1; absorbed = body2; } else { absorber = body2; absorbed = body1; } absorber.mass = totalMass; absorber.vx = newVx; absorber.vy = newVy; absorber.radius = Math.max(1, Math.pow(absorber.mass, 1/3) * 0.15 + 0.5); absorber.color = getColorForMass(absorber.mass); if (showTracks && absorbed.history.length > 1) { persistentTracks.push({ history: [...absorbed.history], color: PERSISTENT_TRACK_COLOR }); } if (absorber === body1) { bodies.splice(j, 1); j--; } else { bodies.splice(i, 1); i--; break; } continue; } const newtonianDenominator = distSq + 0.1; let forceMagnitude = (G * body1.mass * body2.mass) / newtonianDenominator; if (PRECESSION_K_FACTOR !== 0 && distSq > 0.0001) { const precessionMultiplier = 1 + (PRECESSION_K_FACTOR / distSq); forceMagnitude *= Math.max(0, precessionMultiplier); } if(isNaN(forceMagnitude) || !isFinite(forceMagnitude)) { continue; } const forceX = forceMagnitude * dx / dist; const forceY = forceMagnitude * dy / dist; body1.applyForce(forceX, forceY); body2.applyForce(-forceX, -forceY); } } bodies.forEach(body => { if(body) body.update(dt); }); }
        function draw() { ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2); ctx.scale(view.scale, view.scale); ctx.translate(-view.offsetX, -view.offsetY); if (showTracks) { persistentTracks.forEach(track => { if (track.history.length > 1) { ctx.beginPath(); let firstPoint = true; for (let k = 0; k < track.history.length; k++) { if(isNaN(track.history[k].x) || isNaN(track.history[k].y)) continue; if(firstPoint) { ctx.moveTo(track.history[k].x, track.history[k].y); firstPoint = false; } else { ctx.lineTo(track.history[k].x, track.history[k].y); }} if(!firstPoint) { ctx.strokeStyle = getHslaColor(track.color, TRACK_ALPHA); ctx.lineWidth = 1.5 / view.scale; ctx.stroke(); } } }); } bodies.forEach(body => { if(body) body.draw(ctx); }); if (isDraggingSpawn) { const currentMouseWorld = screenToWorld(currentMouseScreenX, currentMouseScreenY); ctx.beginPath(); ctx.moveTo(dragStartWorldX, dragStartWorldY); ctx.lineTo(currentMouseWorld.x, currentMouseWorld.y); ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 2 / view.scale; ctx.setLineDash([5 / view.scale, 5 / view.scale]); ctx.stroke(); ctx.setLineDash([]); const dx_arrow = currentMouseWorld.x - dragStartWorldX; const dy_arrow = currentMouseWorld.y - dragStartWorldY; const angle_arrow = Math.atan2(dy_arrow, dx_arrow); const arrowSize_world = 10 / view.scale; ctx.beginPath(); ctx.moveTo(dragStartWorldX, dragStartWorldY); ctx.lineTo(dragStartWorldX + arrowSize_world * Math.cos(angle_arrow - Math.PI + Math.PI / 6), dragStartWorldY + arrowSize_world * Math.sin(angle_arrow - Math.PI + Math.PI / 6)); ctx.moveTo(dragStartWorldX, dragStartWorldY); ctx.lineTo(dragStartWorldX + arrowSize_world * Math.cos(angle_arrow - Math.PI - Math.PI / 6), dragStartWorldY + arrowSize_world * Math.sin(angle_arrow - Math.PI - Math.PI / 6)); ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)'; ctx.lineWidth = 2 / view.scale; ctx.stroke(); const predictedPath = []; let probeX = dragStartWorldX; let probeY = dragStartWorldY; let probeVx = (currentMouseWorld.x - dragStartWorldX) * VELOCITY_SCALE; let probeVy = (currentMouseWorld.y - dragStartWorldY) * VELOCITY_SCALE; const probeMass = currentSpawnMass; for (let step = 0; step < PREDICTION_STEPS; step++) { let netForceX = 0; let netForceY = 0; for (const existing_body of bodies) { if (isNaN(existing_body.x) || isNaN(existing_body.y) || isNaN(existing_body.mass)) continue; const dx_p = existing_body.x - probeX; const dy_p = existing_body.y - probeY; const distSq_p = dx_p * dx_p + dy_p * dy_p; if (distSq_p > 0.0001) { const dist_p = Math.sqrt(distSq_p); let force_p_newtonian = (G * probeMass * existing_body.mass) / (distSq_p + 0.1); let force_p_total = force_p_newtonian; if (PRECESSION_K_FACTOR !== 0 && distSq_p > 0.0001) { const precessionMultiplier_p = 1 + (PRECESSION_K_FACTOR / distSq_p); force_p_total *= Math.max(0, precessionMultiplier_p); } netForceX += force_p_total * dx_p / dist_p; netForceY += force_p_total * dy_p / dist_p; } } const probeAx = netForceX / probeMass; const probeAy = netForceY / probeMass; probeVx += probeAx * PREDICTION_DT; probeVy += probeAy * PREDICTION_DT; probeX += probeVx * PREDICTION_DT; probeY += probeVy * PREDICTION_DT; predictedPath.push({ x: probeX, y: probeY }); } if (predictedPath.length > 0) { ctx.lineWidth = 1.0 / view.scale; let lastPredX = dragStartWorldX; let lastPredY = dragStartWorldY; for (let i = 0; i < predictedPath.length; i++) { const point = predictedPath[i]; if (isNaN(point.x) || isNaN(point.y)) continue; const alpha = PREDICTION_MAX_ALPHA * (1 - (i / PREDICTION_STEPS)); if (alpha <= 0.01) break;  ctx.beginPath(); ctx.moveTo(lastPredX, lastPredY); ctx.lineTo(point.x, point.y); ctx.strokeStyle = `rgba(${PREDICTION_LINE_BASE_COLOR.r}, ${PREDICTION_LINE_BASE_COLOR.g}, ${PREDICTION_LINE_BASE_COLOR.b}, ${alpha})`; ctx.stroke(); lastPredX = point.x; lastPredY = point.y; } } } ctx.restore(); if (isDraggingSpawn) { const currentMouseWorld = screenToWorld(currentMouseScreenX, currentMouseScreenY); const dragVectorLengthWorld = Math.sqrt((currentMouseWorld.x - dragStartWorldX)**2 + (currentMouseWorld.y - dragStartWorldY)**2); const powerValue = dragVectorLengthWorld * VELOCITY_SCALE * POWER_DISPLAY_SCALE_FACTOR; ctx.font = "14px Arial"; ctx.fillStyle = "rgba(200, 200, 200, 0.8)"; ctx.textAlign = "left"; const textX = currentMouseScreenX + 15; const textY = currentMouseScreenY - 15; ctx.fillText(`Power: ${powerValue.toFixed(1)}`, textX, textY); } }
        function gameLoop() { if (!isPaused) { updatePhysics(DT); } draw(); requestAnimationFrame(gameLoop); }
        
        populateProtoDiskInputs();
        setupProtoDiskParamListeners();
        makeFieldsetCollapsible('protoDiskParamsLegend', 'protoDiskParamsContent', true); 
        gameLoop();
    </script>
</body>
</html>