<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: black; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        canvas { display: block; cursor: crosshair; }
        .controls { position: absolute; top: 10px; left: 10px; background-color: rgba(50, 50, 50, 0.8); padding: 10px; border-radius: 5px; z-index: 10; }
        .controls label { margin-right: 10px; }
        .controls input[type="radio"], .controls input[type="checkbox"] { margin-right: 5px; }
        .controls button { margin-top: 5px; }
        .info { position: absolute; bottom: 10px; left: 10px; font-size: 0.8em; color: #aaa; background-color: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px;}
    </style>
</head>
<body>
    <div class="controls">
        <label>Spawn Mass:</label>
        <input type="radio" name="mass" value="1" id="mass1"> <label for="mass1">1</label>
        <input type="radio" name="mass" value="100" id="mass100" checked> <label for="mass100">100</label>
        <input type="radio" name="mass" value="1000" id="mass1000"> <label for="mass1000">1k</label>
        <input type="radio" name="mass" value="10000" id="mass10k"> <label for="mass10k">10k</label>
        <input type="radio" name="mass" value="100000" id="mass100k"> <label for="mass100k">100k</label>
        <br>
        <input type="checkbox" id="toggleTracks"> <label for="toggleTracks">Show Tracks</label>
        <button id="clearAll">Clear All & Reset View</button>
        <button id="generateDisk">Generate Proto-Disk (with Center Mass)</button>
    </div>

    <canvas id="gravityCanvas"></canvas>
    <div class="info">
        Left-click & drag to spawn (power shown). Alt + Left-click on object to stop it. <br>
        Right-click while dragging to cancel. Middle-click+drag to Pan. Wheel to Zoom. <br>
        Ctrl + Right-click on object to delete (track turns red).
    </div>

    <script>
        const canvas = document.getElementById('gravityCanvas');
        const ctx = canvas.getContext('2d');

        let bodies = [];
        let persistentTracks = [];
        let G = 0.5;
        const DT = 0.016;
        const VELOCITY_SCALE = 0.05; // Used for actual velocity calculation
        const POWER_DISPLAY_SCALE = 1; // Multiplier for the displayed power value (tune for readability)
        const PERSISTENT_TRACK_COLOR = 'hsl(0, 90%, 60%)';
        const TRACK_ALPHA = 0.7;
        const DEFAULT_BODY_COLOR = 'hsl(270, 70%, 70%)';

        let showTracks = false;
        let currentSpawnMass = 100;

        const view = { scale: 1.0, offsetX: 0, offsetY: 0, minZoom: 0.05, maxZoom: 20 };
        let isDraggingSpawn = false, dragStartWorldX, dragStartWorldY, currentMouseScreenX, currentMouseScreenY;
        let isPanning = false, panLastScreenX, panLastScreenY;

        // --- Color Logic & Other Utilities (Copied from previous working version) ---
        const colorStops = [ /* ... */ ];
        colorStops.forEach(stop => { /* ... */ });
        function parseHslString(hslStr) { /* ... */ }
        function formatHslString(h, s, l) { /* ... */ }
        function hslToRgb(h, s, l) { /* ... */ }
        function rgbToHsl(r, g, b) { /* ... */ }
        function getColorForMass(mass) { /* ... */ }
        function getHslaColor(hslColorString, alpha) { /* ... */ }
        // (Full, robust versions of these functions should be here)
        const _colorStopsData = [ { mass: 1, hslStr: 'hsl(0, 100%, 50%)' },{ mass: 100, hslStr: 'hsl(30, 100%, 50%)' },{ mass: 1000, hslStr: 'hsl(60, 100%, 50%)' },{ mass: 10000, hslStr: 'hsl(195, 100%, 70%)' },{ mass: 100000, hslStr: 'hsl(0, 0%, 100%)' }];
        _colorStopsData.forEach(s => { const p = parseHslString(s.hslStr); if(p) {s.h=p.h; s.s=p.s; s.l=p.l; const rgb = hslToRgb(p.h,p.s,p.l); if(!isNaN(rgb.r)){s.r=rgb.r;s.g=rgb.g;s.b=rgb.b;} else {s.r=128;s.g=128;s.b=128;}} else {s.r=128;s.g=128;s.b=128;} });
        colorStops.splice(0, colorStops.length, ..._colorStopsData);
        function parseHslString(hslStr){const m=hslStr.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/); return m?{h:parseInt(m[1]),s:parseInt(m[2])/100,l:parseInt(m[3])/100}:null;}
        function formatHslString(h,s,l){return isNaN(h)||isNaN(s)||isNaN(l)?DEFAULT_BODY_COLOR:`hsl(${Math.round(h)}, ${Math.round(s*100)}%, ${Math.round(l*100)}%)`;}
        function hslToRgb(h,s,l){let r,g,b;if(s===0){r=g=b=l;}else{const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;const H=h/360;const t=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};r=t(p,q,H+1/3);g=t(p,q,H);b=t(p,q,H-1/3);}return{r:Math.round(r*255),g:Math.round(g*255),b:Math.round(b*255)};}
        function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;const M=Math.max(r,g,b),m=Math.min(r,g,b);let h,s,l=(M+m)/2;if(M===m){h=0;s=0;}else{const d=M-m;s=l>0.5?d/(2-M-m):d/(M+m);switch(M){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;}h/=6;}if(isNaN(h))h=0;if(isNaN(s))s=0;return{h:h*360,s:s,l:l};}
        function getColorForMass(m){try{if(isNaN(m)||!isFinite(m))return DEFAULT_BODY_COLOR;if(m<=colorStops[0].mass)return colorStops[0].hslStr;for(let i=0;i<colorStops.length-1;i++){const ls=colorStops[i],us=colorStops[i+1];if(m<=us.mass){if(isNaN(ls.r)||isNaN(us.r))return DEFAULT_BODY_COLOR;const rg=us.mass-ls.mass;if(rg===0)return us.hslStr;const t=(m-ls.mass)/rg;const r=Math.round(ls.r*(1-t)+us.r*t),g=Math.round(ls.g*(1-t)+us.g*t),b=Math.round(ls.b*(1-t)+us.b*t);const hsl=rgbToHsl(r,g,b);return formatHslString(hsl.h,hsl.s,hsl.l);}}return colorStops[colorStops.length-1].hslStr;}catch(e){return DEFAULT_BODY_COLOR;}}
        function getHslaColor(hsl,a){if(typeof hsl!=='string'||!hsl.startsWith('hsl('))hsl=DEFAULT_BODY_COLOR;return hsl.replace('hsl(','hsla(').replace(')',`, ${a})`);}
        // --- End Color Logic ---

        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight;}
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function screenToWorld(screenX, screenY) { const worldX = (screenX - canvas.width / 2) / view.scale + view.offsetX; const worldY = (screenY - canvas.height / 2) / view.scale + view.offsetY; return { x: worldX, y: worldY }; }
        // World to screen for UI elements
        function worldToScreen(worldX, worldY) { const screenX = (worldX - view.offsetX) * view.scale + canvas.width / 2; const screenY = (worldY - view.offsetY) * view.scale + canvas.height / 2; return { x: screenX, y: screenY };}


        document.querySelectorAll('input[name="mass"]').forEach(radio => { radio.addEventListener('change', (event) => { currentSpawnMass = parseFloat(event.target.value); }); });
        currentSpawnMass = parseFloat(document.querySelector('input[name="mass"]:checked').value);

        const toggleTracksCheckbox = document.getElementById('toggleTracks');
        toggleTracksCheckbox.addEventListener('change', (event) => { showTracks = event.target.checked; if (!showTracks) { bodies.forEach(body => body.history = []); persistentTracks = []; }});
        
        document.getElementById('clearAll').addEventListener('click', () => { bodies = []; persistentTracks = []; view.scale = 1.0; view.offsetX = 0; view.offsetY = 0; });

        class CelestialBody { /* ... (same as before, full robust version) ... */
            constructor(x,y,vx,vy,mass){this.x=x;this.y=y;this.vx=vx;this.vy=vy;if(isNaN(mass)||mass<=0)this.mass=1;else this.mass=mass;this.radius=Math.max(2,Math.pow(this.mass,1/3)*.5+1);this.color=getColorForMass(this.mass);this.history=[];this.ax=0;this.ay=0;}
            applyForce(fx,fy){if(isNaN(fx)||isNaN(fy))return;if(this.mass===0)return;this.ax+=fx/this.mass;this.ay+=fy/this.mass;}
            update(dt){if(isNaN(this.ax)||isNaN(this.ay)){this.ax=0;this.ay=0;}this.vx+=this.ax*dt;this.vy+=this.ay*dt;if(isNaN(this.vx)||isNaN(this.vy)){this.vx=0;this.vy=0;}this.x+=this.vx*dt;this.y+=this.vy*dt;if(isNaN(this.x)||isNaN(this.y)){bodies=bodies.filter(b=>b!==this);return;}this.ax=0;this.ay=0;if(showTracks)this.history.push({x:this.x,y:this.y});}
            draw(ctx){if(showTracks&&this.history.length>1){ctx.beginPath();let firstValid=true; for(let i=0;i<this.history.length;i++){if(isNaN(this.history[i].x)||isNaN(this.history[i].y))continue; if(firstValid){ctx.moveTo(this.history[i].x,this.history[i].y);firstValid=false;}else{ctx.lineTo(this.history[i].x,this.history[i].y);}} if(!firstValid) {ctx.strokeStyle=getHslaColor(this.color,TRACK_ALPHA);ctx.lineWidth=1.5/view.scale;ctx.stroke();}}ctx.beginPath();if(isNaN(this.x)||isNaN(this.y)||isNaN(this.radius)||this.radius<=0)return;ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.fillStyle=this.color;ctx.fill();}
        }
        
        canvas.addEventListener('mousedown', (event) => { /* ... (same as before, full robust version) ... */ const worldMouse = screenToWorld(event.clientX, event.clientY); if (event.altKey && event.button === 0) { event.preventDefault(); for (let i = 0; i < bodies.length; i++) { const body = bodies[i]; if (isNaN(body.x) || isNaN(body.y) || isNaN(body.radius) || body.radius <= 0) continue; const distSq = (body.x - worldMouse.x)**2 + (body.y - worldMouse.y)**2; if (distSq < body.radius**2) { body.vx = 0; body.vy = 0; break; } } isDraggingSpawn = false;  } else if (event.button === 0 && !isDraggingSpawn && !isPanning && !event.altKey) { isDraggingSpawn = true; dragStartWorldX = worldMouse.x; dragStartWorldY = worldMouse.y; currentMouseScreenX = event.clientX; currentMouseScreenY = event.clientY; } else if (event.button === 1) { isPanning = true; panLastScreenX = event.clientX; panLastScreenY = event.clientY; canvas.style.cursor = 'grabbing'; event.preventDefault(); }});
        window.addEventListener('mousemove', (event) => { /* ... (same as before) ... */ if (isDraggingSpawn) { currentMouseScreenX = event.clientX; currentMouseScreenY = event.clientY; } else if (isPanning) { const dxScreen = event.clientX - panLastScreenX; const dyScreen = event.clientY - panLastScreenY; view.offsetX -= dxScreen / view.scale; view.offsetY -= dyScreen / view.scale; panLastScreenX = event.clientX; panLastScreenY = event.clientY; }});
        window.addEventListener('mouseup', (event) => { /* ... (same as before) ... */ if (event.button === 0 && isDraggingSpawn) { const endMouseWorld = screenToWorld(currentMouseScreenX, currentMouseScreenY); const dxWorld = endMouseWorld.x - dragStartWorldX; const dyWorld = endMouseWorld.y - dragStartWorldY; const initialVx = dxWorld * VELOCITY_SCALE; const initialVy = dyWorld * VELOCITY_SCALE; bodies.push(new CelestialBody(dragStartWorldX, dragStartWorldY, initialVx, initialVy, currentSpawnMass)); isDraggingSpawn = false; } else if (event.button === 1 && isPanning) { isPanning = false; canvas.style.cursor = 'crosshair'; }});
        canvas.addEventListener('wheel', (event) => { /* ... (same as before) ... */ event.preventDefault(); const scrollDelta = Math.sign(event.deltaY); const zoomFactor = 0.1; const mouseBeforeZoomWorld = screenToWorld(event.clientX, event.clientY); let newScale = view.scale * (1 - scrollDelta * zoomFactor); newScale = Math.max(view.minZoom, Math.min(view.maxZoom, newScale)); view.scale = newScale; view.offsetX = mouseBeforeZoomWorld.x - (event.clientX - canvas.width / 2) / view.scale; view.offsetY = mouseBeforeZoomWorld.y - (event.clientY - canvas.height / 2) / view.scale;});
        canvas.addEventListener('contextmenu', (event) => { /* ... (same as before) ... */ event.preventDefault(); if (event.ctrlKey) { const mouseWorld = screenToWorld(event.clientX, event.clientY); for (let i = bodies.length - 1; i >= 0; i--) { const body = bodies[i]; if (isNaN(body.x) || isNaN(body.y) || isNaN(body.radius)) continue; const distSq = (body.x - mouseWorld.x)**2 + (body.y - worldMouse.y)**2; if (distSq < body.radius**2) { if (showTracks && body.history.length > 1) { persistentTracks.push({ history: [...body.history], color: PERSISTENT_TRACK_COLOR }); } bodies.splice(i, 1); break;}}} else if (isDraggingSpawn) { isDraggingSpawn = false; }});
        
        document.getElementById('generateDisk').addEventListener('click', generateProtoDisk);
        function generateProtoDisk() { /* ... (same as before, full robust version) ... */ const diskCenterX = view.offsetX; const diskCenterY = view.offsetY; const numObjects = 200; const centralMassValue = 5000; const minDiskRadius = 50; const maxDiskRadius = 300; const minParticleMass = 0.5; const maxParticleMass = 5; const diskRotationSpeedMultiplier = 0.8; const velocityRandomnessFactor = 0.15; bodies.push(new CelestialBody(diskCenterX, diskCenterY, 0, 0, centralMassValue)); for (let i = 0; i < numObjects; i++) { const angle = Math.random() * 2 * Math.PI; const radiusFactor = Math.sqrt(Math.random()); const r = minDiskRadius + radiusFactor * (maxDiskRadius - minDiskRadius); const particleMass = minParticleMass + Math.random() * (maxParticleMass - minParticleMass); const posX = diskCenterX + r * Math.cos(angle); const posY = diskCenterY + r * Math.sin(angle); let speed = 0; if (r > 0.01) { speed = Math.sqrt(G * centralMassValue / r); } speed *= diskRotationSpeedMultiplier; let vx_tangential = -speed * Math.sin(angle); let vy_tangential =  speed * Math.cos(angle); const scatterMagnitude = velocityRandomnessFactor * speed; const vx_scatter = (Math.random() - 0.5) * 2 * scatterMagnitude; const vy_scatter = (Math.random() - 0.5) * 2 * scatterMagnitude; const final_vx = vx_tangential + vx_scatter; const final_vy = vy_tangential + vy_scatter; bodies.push(new CelestialBody(posX, posY, final_vx, final_vy, particleMass)); } console.log(`Generated disk with ${numObjects} particles and a central mass of ${centralMassValue}.`); }

        function updatePhysics(dt) { /* ... (same as before, full robust version) ... */ }
        // Full robust updatePhysics:
        function updatePhysics(dt) { for (let i = 0; i < bodies.length; i++) { for (let j = i + 1; j < bodies.length; j++) { const body1 = bodies[i]; const body2 = bodies[j]; if (!body1 || !body2 || isNaN(body1.mass) || isNaN(body2.mass) || isNaN(body1.x) || isNaN(body2.x)) { continue; } const dx = body2.x - body1.x; const dy = body2.y - body1.y; const distSq = dx * dx + dy * dy; if (isNaN(distSq)) { continue; } const dist = Math.sqrt(distSq); if (dist < body1.radius + body2.radius && dist > 0.001) { const totalMass = body1.mass + body2.mass; if (isNaN(totalMass) || totalMass <=0) { continue; } const newVx = (body1.mass * body1.vx + body2.mass * body2.vx) / totalMass; const newVy = (body1.mass * body1.vy + body2.mass * body2.vy) / totalMass; let absorber, absorbed; if (body1.mass >= body2.mass) { absorber = body1; absorbed = body2; } else { absorber = body2; absorbed = body1; } absorber.mass = totalMass; absorber.vx = newVx; absorber.vy = newVy; absorber.radius = Math.max(2, Math.pow(absorber.mass, 1/3) * 0.5 + 1); absorber.color = getColorForMass(absorber.mass); if (showTracks && absorbed.history.length > 1) { persistentTracks.push({ history: [...absorbed.history], color: PERSISTENT_TRACK_COLOR }); } if (absorber === body1) { bodies.splice(j, 1); j--; } else { bodies.splice(i, 1); i--; break; } continue; } if (dist > 0.001) { const forceMagnitude = (G * body1.mass * body2.mass) / (distSq + 0.1); if(isNaN(forceMagnitude) || !isFinite(forceMagnitude)) { continue; } const forceX = forceMagnitude * dx / dist; const forceY = forceMagnitude * dy / dist; body1.applyForce(forceX, forceY); body2.applyForce(-forceX, -forceY); } } } bodies.forEach(body => { if(body) body.update(dt); }); }


        // MODIFIED: draw() function
        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // --- Draw world objects (transformed) ---
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(view.scale, view.scale);
            ctx.translate(-view.offsetX, -view.offsetY);

            // Draw persistent tracks
            if (showTracks) {
                persistentTracks.forEach(track => {
                    if (track.history.length > 1) {
                        ctx.beginPath(); let firstValid=true;
                        for (let k = 0; k < track.history.length; k++) {
                            if(isNaN(track.history[k].x) || isNaN(track.history[k].y)) continue;
                            if(firstValid){ctx.moveTo(track.history[k].x,track.history[k].y);firstValid=false;}
                            else{ctx.lineTo(track.history[k].x,track.history[k].y);}
                        }
                        if(!firstValid) {
                            ctx.strokeStyle = getHslaColor(track.color, TRACK_ALPHA);
                            ctx.lineWidth = 1.5 / view.scale; ctx.stroke();
                        }
                    }
                });
            }
            // Draw active bodies (and their active tracks)
            bodies.forEach(body => { if(body) body.draw(ctx); });

            // Draw spawn preview line and arrow (in world space)
            if (isDraggingSpawn) {
                const currentMouseWorld = screenToWorld(currentMouseScreenX, currentMouseScreenY);
                ctx.beginPath();
                ctx.moveTo(dragStartWorldX, dragStartWorldY);
                ctx.lineTo(currentMouseWorld.x, currentMouseWorld.y);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2 / view.scale;
                ctx.setLineDash([5 / view.scale, 5 / view.scale]);
                ctx.stroke();
                ctx.setLineDash([]);

                const dx_world_preview = currentMouseWorld.x - dragStartWorldX;
                const dy_world_preview = currentMouseWorld.y - dragStartWorldY;
                const angle_world = Math.atan2(dy_world_preview, dx_world_preview);
                const arrowSize_world = 10 / view.scale;
                ctx.beginPath();
                ctx.moveTo(dragStartWorldX, dragStartWorldY);
                ctx.lineTo(dragStartWorldX + arrowSize_world * Math.cos(angle_world - Math.PI + Math.PI / 6), dragStartWorldY + arrowSize_world * Math.sin(angle_world - Math.PI + Math.PI / 6));
                ctx.moveTo(dragStartWorldX, dragStartWorldY);
                ctx.lineTo(dragStartWorldX + arrowSize_world * Math.cos(angle_world - Math.PI - Math.PI / 6), dragStartWorldY + arrowSize_world * Math.sin(angle_world - Math.PI - Math.PI / 6));
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.lineWidth = 2 / view.scale;
                ctx.stroke();
            }
            ctx.restore(); // Restore transform before drawing screen-space UI elements

            // --- Draw screen-space UI elements (like the power value) ---
            if (isDraggingSpawn) {
                const dx_screen = currentMouseScreenX - dragStartWorldX * view.scale + view.offsetX * view.scale - canvas.width/2 + dragStartWorldX; // This is tricky, better to use screen coords for drag distance for text
                const dy_screen = currentMouseScreenY - dragStartWorldY * view.scale + view.offsetY * view.scale - canvas.height/2 + dragStartWorldY;
                
                // For power display, it's easier to use the screen-space drag distance directly,
                // then convert start/end to world for physics, but for display, screen distance is fine.
                // Let's use the world-space vector length for consistency with velocity calculation.
                const currentMouseWorld = screenToWorld(currentMouseScreenX, currentMouseScreenY);
                const dragVectorLengthWorld = Math.sqrt(
                    (currentMouseWorld.x - dragStartWorldX)**2 + 
                    (currentMouseWorld.y - dragStartWorldY)**2
                );

                // The actual velocity magnitude will be dragVectorLengthWorld * VELOCITY_SCALE.
                // We can display this directly or scale it further.
                const powerValue = dragVectorLengthWorld * VELOCITY_SCALE * 100; // Multiply by 100 for nicer numbers

                ctx.font = "14px Arial";
                ctx.fillStyle = "rgba(200, 200, 200, 0.8)";
                ctx.textAlign = "left";
                // Display text near the current mouse cursor
                const textX = currentMouseScreenX + 15;
                const textY = currentMouseScreenY - 15;
                ctx.fillText(`Power: ${powerValue.toFixed(1)}`, textX, textY);
            }
        }

        function gameLoop() { updatePhysics(DT); draw(); requestAnimationFrame(gameLoop); }
        gameLoop();
    </script>
</body>
</html>